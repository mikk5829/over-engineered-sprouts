#!/usr/bin/env node

/**
 * Module dependencies.
 */
const app = require('../app');
const debug = require('debug')('over-engineered-sprout:server');
const http = require('http');
const sentencer = require('sentencer');
const math = require('mathjs');
const db = require('../server/db/simple-db')

var paper = require('paper');
// var CollisionGrid = require('./CollisionGrid');
paper.install(this);
paper.setup([750, 472]);

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port, function () {
    console.log(`Listening on port ${port.valueOf()}`)
});

server.on('error', onError);
server.on('listening', onListening);


/*
* Socket IO
* */
const io = require('socket.io').listen(server);
let activeRooms = new Map();

function makeid(length) {
    var result = '';
    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var charactersLength = characters.length;
    for (var i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}

io.sockets.on('connect', function (socket) {

    // Client has submitted a path -> server will validate the path
    socket.on('submitPath', (pathJson, fromId, toId, fn) => {
        if (!activeRooms.has(socket.room)) return false;

        let gameRoom = activeRooms.get(socket.room);
        if (socket.playerNum !== gameRoom) fn(false);
        console.log(`${socket.username} in game ${gameRoom.name} submits a path`);


        let from = gameRoom.points[fromId];
        let to = gameRoom.points[toId];
        let path = new paper.Path().importJSON(pathJson);

        // Check if the move is legal
        if (!gameRoom.isLegal(from, to, path)) fn(false); // Callback - path not accepted

        else {
            fn(true); // Callback - path accepted

            let resp = gameRoom.addPath(from, to, path);
            io.sockets.in(socket.room).emit('updateGame', from.data.id, to.data.id, resp.path, resp.pointData, gameRoom.nextTurn());

            if (gameRoom.isGameOver()) {
                let loser = gameRoom.player1 === socket ? gameRoom.player2 : gameRoom.player1;
                gameRoom.endGame(socket, loser);
                io.sockets.in(socket.room).emit('gameOver', socket.playerNum);
            }
        }


    });

    // TODO: Only emit to lobby socket
    setInterval(function () {
        let roomList = [];
        for (let room of activeRooms.values()) {
            roomList.push(room.lobbyRepresentation());
        }
        socket.emit('updateLobby', roomList);
    }, 1000);

    // when the client emits 'join', this listens and executes
    socket.on('join', (requestedUsername, fn) => {
        console.log("Client wants to join with username", requestedUsername);

        String.prototype.capitalize = function () {
            return this.charAt(0).toUpperCase() + this.slice(1);
        };

        let username;
        if (usernameIsValid(requestedUsername)) {
            username = requestedUsername;
        } else {
            do {
                let randInt = Math.floor(Math.random() * 10);
                let adjective = sentencer.make("{{ adjective }}").capitalize();
                username = adjective + "Guest" + randInt;
            } while (getSockets().some(e => e.username === username));
        }
        socket.username = username;
        console.log("Added user", username);
        db.createUser(username);
        fn(username);
    });

    socket.on('suggestPath', (from, to, fn) => {
        if (!activeRooms.has(socket.room)) return false;
        let game = activeRooms.get(socket.room);
        let pos1 = game.points[from].position;
        let pos2 = game.points[to].position;
        fn(game.possibleMove(pos1, pos2));
    });

    socket.on('changeUsername', (requestedUsername, fn) => {
        // TODO: Change username in JSON database!
        if (usernameIsValid(requestedUsername)) {
            console.log(`${socket.username} changed their username to ${requestedUsername}`);
            db.changeUsername(socket.username, requestedUsername);
            socket.username = requestedUsername;
            fn(true);
        } else fn(false)
    });

    socket.on('joinRoom', function (id, fn) {
        console.log(`${socket.username} wants to join room with id ${id}`);
        let game = activeRooms.has(id) ? activeRooms.get(id) : null;
        if (!game || game.playerCount >= 2) fn(false);
        else {
            let playerNum = game.userJoin(socket);
            fn(true, playerNum);

            if (game.playerCount === 2) {
                console.log(`2 players connected to game ${id}`);

                // Packs the positions of the points into a list for the clients to read
                let pointPositions = [];
                for (let point of game.init()) {
                    pointPositions.push(point.position);
                }
                io.sockets.in(socket.room).emit('startGame', pointPositions, game.status);
            }
        }
    });

    // Lets the user connect to an existing room if one exists
    // Otherwise prompts them to create their own room
    socket.on('quickPlay', function (fn) {
        // fixme
        for (let room of activeRooms.values()) {
            if (room.playerCount < 2) fn(true, room.id);
        }

        fn(false);
        return false;
    });

    // Client wants to create a new room => server validates room name, creates new room
    socket.on('addRoom', (roomName, fn) => {
        if (activeRooms[roomName] !== undefined) fn(false); // FIXME can't check roomname like this

        if (roomName.length < 1 || roomName.length > 20) fn(false);

        else {
            console.log("Creating new room: " + roomName);
            let id = makeid(6);
            activeRooms.set(id, new GameRoom(id, roomName));
            fn(true, id);
        }
    });

    socket.on('sendChatMsg', function (msg) {
        console.log("Received sendChatMsg from " + socket.username + ": " + msg);
        let timestamp = +new Date();
        io.sockets.in(socket.room).emit('updateChat', timestamp, socket.username, msg);
    });

    socket.on('disconnect', function () {
        console.log(`${socket.username} disconnected`);
        if (activeRooms.has(socket.room)) {
            let game = activeRooms.get(socket.room);
            console.log("has socket.room");
            let response = game.userLeave(socket);
            if (response.status === Status.gameover) {
                console.log("Gameover prematurely", socket.room);
                io.sockets.in(game.id).emit('gameOver', response.winner.playerNum);
                game.endGame(response.winner, response.loser);
            } else if (response.waiting) {
                console.log("Deleting room", socket.room);
                game.endGame();
            }
        }
        socket.leave(socket.room);
    });
});

/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
    let port = parseInt(val, 10);
    if (isNaN(port)) return val;
    if (port >= 0) return port;
    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    var bind = typeof port === 'string'
        ? 'Pipe ' + port
        : 'Port ' + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case 'EACCES':
            console.error(bind + ' requires elevated privileges');
            process.exit(1);
            break;
        case 'EADDRINUSE':
            console.error(bind + ' is already in use');
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
    let addr = server.address();
    let bind = typeof addr === 'string'
        ? 'pipe ' + addr
        : 'port ' + addr.port;
    debug('Listening on ' + bind);
}

function getSockets() {
    return Object.keys(io.sockets.sockets);
}

function usernameIsValid(username) {
    if (!username || !(3 <= username.length <= 15) || !(/^[a-z0-9]+$/i.test(username))) return false;
    return !getSockets().some(e => io.sockets.sockets[e].username === username);
}


const Status = Object.freeze({"player1": 1, "player2": 2, "waiting": 3, "gameover": 4});

function randomPoints(amount) {
    let tileSize = 40;
    let cellSize = 8;
    let width = 750;
    let height = 472;

    let totalTiles = Math.floor(width / tileSize) * Math.floor(height / tileSize);
    let tileMatrix = math.zeros(Math.floor(width / tileSize), Math.floor(height / tileSize), 'sparse');

    // Set edge tiles to 1 to prevent dots being placed partially outside game canvas
    let tileMatrixWidth = Math.floor(width / tileSize);
    let tileMatrixHeight = Math.floor(height / tileSize);
    tileMatrix.subset(math.index(0, math.range(0, tileMatrixHeight)), math.ones(tileMatrixHeight));
    tileMatrix.subset(math.index(tileMatrixWidth - 1, math.range(0, tileMatrixHeight)), math.ones(tileMatrixHeight));
    tileMatrix.subset(math.index(math.range(0, tileMatrixWidth), 0), math.ones(tileMatrixWidth));
    tileMatrix.subset(math.index(math.range(0, tileMatrixWidth), tileMatrixHeight - 1), math.ones(tileMatrixWidth));

    if (amount > totalTiles) {
        console.log("dot_count > totalTiles... t_random won't be able to find enough random tiles!");
    }

    let getIndices = (value) => {
        let indices = [];
        tileMatrix.forEach((val, index, matrix) => {
            if (val === value) {
                indices.push(index);
            }
        });
        return indices;
    };

    let updateMatrix = (index, value) => {
        tileMatrix = tileMatrix.set(index, value);
    };

    let getRandomIndex = (value) => {
        let indices = getIndices(value);
        let randomIndex = Math.floor(Math.random() * indices.length);
        updateMatrix(indices[randomIndex], 1);
        return indices[randomIndex];
    };

    let permuted = [];
    for (let i = 0; i < amount; i++) {
        let randIndex = getRandomIndex(0);
        permuted.push(new paper.Point(randIndex[0] * tileSize, randIndex[1] * tileSize));
    }
    return permuted;

}

class GameRoom {
    constructor(id, name, player1 = null, player2 = null) {
        this.id = id;
        this.name = name;
        this.player1 = player1;
        this.player2 = player2;
        this.playerCount = 0;
        this.maxCapacity = 2;
        this.project = new paper.Project([750, 472]);
        this.lineGroup = new paper.Group();
        this.points = [];
        // this.collisionGrid = null;
        this.gameStarted = false;
        this.status = Status.waiting;
    }

    init(mapConfiguration = null, numPoints = 2) {
        // this.collisionGrid = new CollisionGrid(10, this, new paper.Size(750, 472));

        let dotPoints = [];
        if (!mapConfiguration) {
            dotPoints = randomPoints(numPoints);
        } else {
            dotPoints = randomPoints(mapConfiguration.dots);
        }

        for (let i = 0; i < dotPoints.length; i++) {
            let center = dotPoints[i];
            this.points[i] = this.createPoint(center, i, 0, []);
        }

        let rand = Math.floor(Math.random() * 2);
        this.status = rand === 1 ? Status.player1 : Status.player2;
        this.gameStarted = true;
        return this.points;
    }

    createPoint(pos, id, connections, edges) {
        let point = new paper.Path.Circle({
            center: pos,
            radius: 5,
        });
        point.data = {
            id: id,
            edges: edges,
            connections: connections,
        };

        point.commonEdges = function (p2) {
            let inCommon = [];
            for (let edge of point.data.edges) {
                if (edge.data.vertices.includes(point) && edge.data.vertices.includes(p2))
                    inCommon.push(edge);
            }
            return inCommon;
        };

        point.dfs = function (toFind) {
            //Marker som søgende
            point.data.status = "seeking";
            //Kør dfs på alle naboer
            for (let e of point.data.edges) {
                let p = e.data.vertices.find(x => x !== point);
                if (e !== point.data.rootEdge && p !== undefined) {
                    //Er en nabo søgende eller færdig, find alle links op til nabo og tilføj liste til cycles[]
                    if (p.data.status === "") {
                        //Sæt parent til dette point
                        p.data.root = point;
                        p.data.rootEdge = e;
                        if (!(e.data.vertices[0] === p)) {
                            e.reverse();
                            e.data.vertices.reverse();
                        }
                        p.dfs(toFind);
                    } else if (p.data.status === "done") {
                        toFind.push(e);
                    }
                }
            }
            point.data.status = "done";
        };

        // if (this.collisionGrid != null) {
        //     this.collisionGrid.t_insert_rectangle(point.bounds, point);
        // }


        return point;
    }

    addPath(from, to, path) {
        path.simplify(3);
        let originalPath = path.clone();

        // Create new point at midpoint of path
        let pointId = this.points.length;
        let newPoint = this.createPoint(path.getPointAt(path.length / 2), pointId, 0, []);

        function save(_from, _to, path) {
            _from.data.connections += 1;
            _from.data.edges.push(path);
            _to.data.connections += 1;
            _to.data.edges.push(path);
            path.data.vertices = [_from, _to];
            return path;
        }

        // Separate into 2 subpaths - used for pathfinding
        let path2 = path.splitAt(path.length / 2);
        let path1 = path.clone();
        path1.insert(0, from.position);
        path2.add(to.position);

        save(from, newPoint, path1);
        save(newPoint, to, path2);

        path1.addTo(this.lineGroup);
        path2.addTo(this.lineGroup);
        this.points[pointId] = newPoint;

        // Return the unsplit path and the new poin
        let pointData = {
            // x: newPoint.
            center: newPoint.position,
            id: pointId,
            connections: 2
        };
        //todo: send newPoint.data instead

        return {path: originalPath.exportJSON(), pointData: pointData};
    }

    isLegal(from, to, path) {
        this.project.activate();

        if (!(from || to)) return false;
        else if (from === to && from.data.connections >= 2) return false;
        else if (from.data.connections >= 3 || to.data.connections >= 3) return false;

        // Check for intersections w. existing paths
        for (let line of this.lineGroup.getItems({type: 'path'})) {
            if (path.getIntersections(line).length > 0) return false;
        }
        return path.getIntersections(path).length <= 0;
    }

    getCycles() {
        //TODO: Sørg for at alle edges "vender" rigtigt
        //TODO: Ikke alle kanter i et loop bliver tilføjet selv om loopet er opdaget
        let toFind = [];
        for (let p of this.points) {
            p.data.root = p;
            p.data.rootEdge = null;
            p.data.status = "";
        }
        for (let p of this.points) {
            if (p.data.status !== "done") {
                p.data.root = p;
                p.dfs(toFind);
            }
        }
        let cycles = [];

        for (let t of toFind) {
            let paths0 = [];
            let paths1 = [];
            let loop = [t];
            let p0 = t.data.vertices[0];
            let p1 = t.data.vertices[1];
            while (p0.data.root !== p0) {
                paths0.push(p0.data.rootEdge);
                p0 = p0.data.root;
            }
            while (p1.data.root !== p1) {
                paths1.push(p1.data.rootEdge);
                p1 = p1.data.root;
            }
            let difference = paths0.filter(x => !paths1.includes(x)).concat(paths1.filter(x => !paths0.includes(x)));
            loop = loop.concat(difference);
            cycles.push([...loop]);
        }
        return cycles;
    }

    possibleMove(p1, p2, debug = false) {
        /*TODO: Known bugs
        Sometimes the "parent edge" from DFS will be reversed and create an area outside the cycle. Check if direction is correct?
        If one large cycle is also split into 2 smaller cycles, one of them will be able to access all points on the other, but not vice versa.
         */
        let tot = new paper.Path();

        let cycles = this.getCycles();
        for (let c of cycles) {
            let total = new paper.Path();
            for (let p of c) {
                for (let s of p.segments)
                    total.add(s);
            }

            if (((total.contains(p1) && total.getLocationOf(p1) === null) && !total.contains(p2)) || ((total.contains(p2) && total.getLocationOf(p2) === null) && !total.contains(p1)))
                return false;
            //total.remove();
            // tot.addSegments(total.segments);

        }
        return true;
    }

    lobbyRepresentation() {
        // Returns a representation of this gameroom for the game lobby
        return {
            capacity: `${this.playerCount}/${this.maxCapacity}`,
            id: this.id,
            name: this.name
        }
    }

    userJoin(user) {
        if (this.playerCount < 2) {
            console.log(`User ${user.username} joined game ${this.name}`);

            user.join(this.id);
            user.room = this.id;
            this.playerCount++;

            if ((!this.player1 && !this.player2) || (!this.player1)) {
                this.player1 = user;
                user.playerNum = Status.player1;
                return Status.player1;
            } else if (!this.player2) {
                this.player2 = user;
                user.playerNum = Status.player2;
                return Status.player2;
            }
        }
    }

    nextTurn() {
        this.status = this.status === Status.player1 ? Status.player2 : Status.player1;
        return this.status;
    }

    userLeave(user) {
        console.log(`User ${user.username} left game ${this.name}`);
        this.playerCount--;
        let opponent = this.player1 === user ? this.player2 : this.player1;
        this.player1 = this.player1 === user ? null : this.player1;
        this.player2 = this.player2 === user ? null : this.player2;

        // End game prematurely
        if (this.gameStarted) return {status: Status.gameover, winner: opponent, loser: user};
        else if (this.playerCount < 1) return {status: Status.waiting};
    }

    isGameOver() {
        /*
       * If there is a point with zero or one connections, it can loop back to itself.
       * EDGE CASE: If paths have been drawn very close to the point so a legal loop cannot be drawn.
       * */
        if (this.points.some(p => p.data.connections < 2)) return false;

        let twoConnections = this.points.filter(p => p.data.connections === 2);

        /*
        * If there is 0 or 1 points with 2 connections, and 0 points with <2 connections,
        * no legal paths can be drawn --> game is over.
        * */
        if (twoConnections.length <= 1) return true;

        /*
        * Check if a path can be drawn between any of the points with two connections.
        * */
        for (let point of twoConnections) {
            if (twoConnections.some(p => p !== point && this.possibleMove(point.position, p.position))) return false;
        }
        return true;
    }

    endGame(winner = null, loser = null) {
        this.status = Status.gameover;
        this.gameStarted = false;
        if (winner) db.addWin(winner.username);
        if (loser) db.addLoss(loser.username);
        activeRooms.delete(this.id);
    }
}

