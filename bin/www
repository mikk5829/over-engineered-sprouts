#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('over-engineered-sprout:server');
var http = require('http');
var Sentencer = require('sentencer');
var math = require('mathjs');


var paper = require('paper');
// var CollisionGrid = require('./CollisionGrid');
paper.install(this);
paper.setup([750, 472]);

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port, function () {
    console.log(`Listening on port ${port.valueOf()}`)
});

server.on('error', onError);
server.on('listening', onListening);


/*
* Socket IO
* */
const io = require('socket.io').listen(server);
let activeRooms = new Map();

function makeid(length) {
    var result = '';
    var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    var charactersLength = characters.length;
    for (var i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
    }
    return result;
}

io.sockets.on('connect', function (socket) {

    // Client has submitted a path -> server will validate the path
    socket.on('submitPath', (pathJson, fromId, toId, fn) => {
        console.log(`${socket.username} in game ${socket.room} submits a path`);
        let game = activeRooms.get(socket.room);
        let from = game.points[fromId];
        let to = game.points[toId];
        let path = new paper.Path().importJSON(pathJson);
        // game.collisionGrid.t_insert_line(path.curves, path);


        if (!game.isLegal(from, to, path)) {
            fn(false); // Callback - path not accepted
            // path.remove();
            return false;
        } else {
            fn(true); // Callback - path accepted

            let resp = game.addPath(from, to, path);
            io.sockets.in(socket.room).emit('updateGame', from.data.id, to.data.id, resp.path, resp.pointData, game.nextTurn());
            //path.remove();

            // TODO - check for gameover
            let gameover = false;
            if (gameover) {
                game.gameOver(socket.playerNum);
                io.sockets.in(socket.room).emit('gameOver', winner, loser);
            }

            return true;
        }
    });

    // TODO: Only emit to lobby socket
    setInterval(function () {
        let roomList = [];
        for (let room of activeRooms.values()) {
            roomList.push(room.lobbyRepresentation());
        }
        socket.emit('updateLobby', roomList);
    }, 1000);

    // when the client emits 'join', this listens and executes
    socket.on('join', (requestedUsername, fn) => {
        console.log("Client wants to join with username", requestedUsername);

        String.prototype.capitalize = function () {
            return this.charAt(0).toUpperCase() + this.slice(1);
        };

        let username;
        if (usernameIsValid(requestedUsername)) {
            username = requestedUsername;
        } else {
            do {
                let randInt = Math.floor(Math.random() * 10);
                let adjective = Sentencer.make("{{ adjective }}").capitalize();
                username = adjective + "Guest" + randInt;
            } while (getSockets().some(e => e.username === username));
        }
        socket.username = username;
        console.log("Added user", username);
        fn(username);
    });

    socket.on('suggestPath', (from, to, fn) => {
        let game = activeRooms.get(socket.room);
        console.log("IDs:", game.points[from].data.id, game.points[to].data.id)
        console.log("Positions:", game.points[from].position, game.points[to].position)
        let pos1 = game.points[from].position;
        let pos2 = game.points[to].position;
        let total = game.possibleMove(pos1, pos2);
        if (total === false) {
            fn(false);
        } else {
            console.log("321",total.exportJSON())
            fn(total.exportJSON());
        }


        // let suggestedPath = game.suggestPath(game.points[from], game.points[to]);
        // fn(suggestedPath.exportJSON());
    });

    socket.on('changeUsername', (requestedUsername, fn) => {
        if (usernameIsValid(requestedUsername)) {
            console.log(`${socket.username} changed their username to ${requestedUsername}`);
            socket.username = requestedUsername;
            fn(true);
        } else fn(false)
    });

    socket.on('joinRoom', function (id, fn) {
        console.log(`${socket.username} wants to join room with id ${id}`);
        let game = activeRooms.has(id) ? activeRooms.get(id) : null;
        if (!game || game.playerCount >= 2) fn(false);
        else {
            let playerNum = game.userJoin(socket);
            fn(true, playerNum);

            if (game.playerCount === 2) {
                console.log(`2 players connected to game ${id}`);

                // Packs the positions of the points into a list for the clients to read
                let pointPositions = [];
                for (let point of game.init()) {
                    pointPositions.push(point.position);
                }
                io.sockets.in(socket.room).emit('startGame', pointPositions, game.status);
            }
        }
    });

    // Lets the user connect to an existing room if one exists
    // Otherwise prompts them to create their own room
    socket.on('quickPlay', function (fn) {
        // fixme
        for (let room of activeRooms.values()) {
            if (room.playerCount < 2) fn(true, room.id);
        }

        fn(false);
        return false;
    });

    // Client wants to create a new room => server validates room name, creates new room
    socket.on('addRoom', (roomName, fn) => {
        if (activeRooms[roomName] !== undefined) fn(false); // FIXME can't check roomname like this

        if (roomName.length < 1 || roomName.length > 20) fn(false);

        else {
            console.log("Creating new room: " + roomName);
            let id = makeid(6);
            activeRooms.set(id, new GameRoom(id, roomName));
            fn(true, id);
        }
    });

    socket.on('sendChatMsg', function (msg) {
        console.log("Received sendChatMsg from " + socket.username + ": " + msg);
        let timestamp = +new Date();
        io.sockets.in(socket.room).emit('updateChat', timestamp, socket.username, msg);
    });

    socket.on('disconnect', function () {
        console.log(`${socket.username} disconnected`);
        if (activeRooms.has(socket.room)) {
            activeRooms.get(socket.room).userLeave(socket);
        }
        socket.leave(socket.room);
    });
});

/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
    let port = parseInt(val, 10);
    if (isNaN(port)) return val;
    if (port >= 0) return port;
    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    var bind = typeof port === 'string'
        ? 'Pipe ' + port
        : 'Port ' + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case 'EACCES':
            console.error(bind + ' requires elevated privileges');
            process.exit(1);
            break;
        case 'EADDRINUSE':
            console.error(bind + ' is already in use');
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
    let addr = server.address();
    let bind = typeof addr === 'string'
        ? 'pipe ' + addr
        : 'port ' + addr.port;
    debug('Listening on ' + bind);
}

function getSockets() {
    return Object.keys(io.sockets.sockets);
}

function usernameIsValid(username) {
    if (!username || !(3 <= username.length <= 15) || !(/^[a-z0-9]+$/i.test(username))) return false;
    return !getSockets().some(e => io.sockets.sockets[e].username === username);
}


const Status = Object.freeze({"player1": 1, "player2": 2, "waiting": 3, "gameover": 4});

function randomPoints(amount) {
    let tileSize = 40;
    let cellSize = 8;
    let width = 750;
    let height = 472;

    let totalTiles = Math.floor(width / tileSize) * Math.floor(height / tileSize);
    let tileMatrix = math.zeros(Math.floor(width / tileSize), Math.floor(height / tileSize), 'sparse');

    // Set edge tiles to 1 to prevent dots being placed partially outside game canvas
    let tileMatrixWidth = Math.floor(width / tileSize);
    let tileMatrixHeight = Math.floor(height / tileSize);
    tileMatrix.subset(math.index(0, math.range(0, tileMatrixHeight)), math.ones(tileMatrixHeight));
    tileMatrix.subset(math.index(tileMatrixWidth - 1, math.range(0, tileMatrixHeight)), math.ones(tileMatrixHeight));
    tileMatrix.subset(math.index(math.range(0, tileMatrixWidth), 0), math.ones(tileMatrixWidth));
    tileMatrix.subset(math.index(math.range(0, tileMatrixWidth), tileMatrixHeight - 1), math.ones(tileMatrixWidth));

    if (amount > totalTiles) {
        console.log("dot_count > totalTiles... t_random won't be able to find enough random tiles!");
    }

    let getIndices = (value) => {
        let indices = [];
        tileMatrix.forEach((val, index, matrix) => {
            if (val === value) {
                indices.push(index);
            }
        });
        return indices;
    };

    let updateMatrix = (index, value) => {
        tileMatrix = tileMatrix.set(index, value);
    };

    let getRandomIndex = (value) => {
        let indices = getIndices(value);
        let randomIndex = Math.floor(Math.random() * indices.length);
        updateMatrix(indices[randomIndex], 1);
        return indices[randomIndex];
    };

    let permuted = [];
    for (let i = 0; i < amount; i++) {
        let randIndex = getRandomIndex(0);
        permuted.push(new paper.Point(randIndex[0] * tileSize, randIndex[1] * tileSize));
    }
    return permuted;

}

class GameRoom {
    constructor(id, name, player1 = null, player2 = null) {
        this.id = id;
        this.name = name;
        this.player1 = player1;
        this.player2 = player2;
        this.playerCount = 0;
        this.maxCapacity = 2;
        this.project = new paper.Project([750, 472]);
        this.lineGroup = new paper.Group();
        this.points = [];
        // this.collisionGrid = null;
        this.gameStarted = false;
        this.status = Status.waiting;
    }

    init(mapConfiguration = null, numPoints = 10) {
        // this.collisionGrid = new CollisionGrid(8, this, new paper.Size(750, 472));

        let dotPoints = [];
        if (!mapConfiguration) {
            dotPoints = randomPoints(numPoints);
        } else {
            dotPoints = randomPoints(mapConfiguration.dots);
        }

        for (let i = 0; i < dotPoints.length; i++) {
            let center = dotPoints[i];
            this.points[i] = this.createPoint(center, i, 0, []);
        }

        let rand = Math.floor(Math.random() * 2);
        this.status = rand === 1 ? Status.player1 : Status.player2;
        this.gameStarted = true;
        return this.points;
    }

    createPoint(pos, id, connections, edges) {
        let point = new paper.Path.Circle({
            center: pos,
            radius: 10,
        });
        point.data = {
            id: id,
            edges: edges,
            connections: connections,
        };

        point.commonEdges = function (p2) {
            let inCommon = [];
            for (let edge of point.data.edges) {
                if (edge.data.vertices.includes(point) && edge.data.vertices.includes(p2))
                    inCommon.push(edge);
            }
            return inCommon;
        };

        point.dfs = function (toFind) {
            console.log("dfs on point", point.data.id)
            //Marker som søgende
            point.data.status = "seeking";
            //Kør dfs på alle naboer
            for (let e of point.data.edges) {
                let p = e.data.vertices.find(x => x !== point);
                if (e !== point.data.rootEdge && p !== undefined) {
                    //Er en nabo søgende eller færdig, find alle links op til nabo og tilføj liste til cycles[]
                    if (p.data.status === "") {
                        //Sæt parent til dette point
                        p.data.root = point;
                        p.data.rootEdge = e;
                        if (!(e.data.vertices[0] === p)) {
                            e.reverse();
                            e.data.vertices.reverse();
                        }
                        p.dfs(toFind);
                    } else if (p.data.status === "done") {
                        toFind.push(e);
                    }
                }
            }
            point.data.status = "done";
        };

        // if (this.collisionGrid != null) {
        //     this.collisionGrid.t_insert_rectangle(point.bounds, point);
        // }


        return point;
    }

    addPath(from, to, path) {
        path.simplify(3);
        let originalPath = path.clone();

        // Create new point at midpoint of path
        let pointId = this.points.length;
        let newPoint = this.createPoint(path.getPointAt(path.length / 2), pointId, 0, []);

        function save(_from, _to, path) {
            _from.data.connections += 1;
            _from.data.edges.push(path);
            _to.data.connections += 1;
            _to.data.edges.push(path);
            path.data.vertices = [_from, _to];
            return path;
        }

        // Separate into 2 subpaths - used for pathfinding
        let path2 = path.splitAt(path.length / 2);
        let path1 = path.clone();
        path1.insert(0, from.position);
        path2.add(to.position);

        save(from, newPoint, path1);
        save(newPoint, to, path2);

        path1.addTo(this.lineGroup);
        path2.addTo(this.lineGroup);
        path.addTo(this.lineGroup); // FIXME?
        this.points[pointId] = newPoint;

        // Return the unsplit path and the new poin
        let pointData = {
            // x: newPoint.
            center: newPoint.position,
            id: pointId,
            connections: 2
        };
        //todo: send newPoint.data instead

        return {path: originalPath.exportJSON(), pointData: pointData};
    }

    isLegal(from, to, path) {
        this.project.activate();

        if (!(from || to)) return false;
        else if (from === to && from.data.connections >= 2) return false;
        else if (from.data.connections >= 3 || to.data.connections >= 3) return false;

        // Check for intersections w. existing paths
        for (let line of this.lineGroup.getItems({type: 'path'})) {
            if (path.getIntersections(line).length > 0) return false;
        }
        return path.getIntersections(path).length <= 0;
    }

    getCycles() {
        //TODO: Sørg for at alle edges "vender" rigtigt
        //TODO: Ikke alle kanter i et loop bliver tilføjet selv om loopet er opdaget
        let toFind = [];
        for (let p of this.points) {
            p.data.root = p;
            p.data.rootEdge = null;
            p.data.status = "";
        }
        for (let p of this.points) {
            if (p.data.status !== "done") {
                p.data.root = p;
                p.dfs(toFind);
            }
        }
        console.log("tofind length:", toFind.length)
        let cycles = [];

        for (let t of toFind) {
            let paths0 = [];
            let paths1 = [];
            let loop = [t];
            let p0 = t.data.vertices[0];
            let p1 = t.data.vertices[1];
            console.log(p0.data.id, p1.data.id)
            while (p0.data.root !== p0) {
                paths0.push(p0.data.rootEdge);
                p0 = p0.data.root;
            }
            while (p1.data.root !== p1) {
                paths1.push(p1.data.rootEdge);
                p1 = p1.data.root;
            }
            let difference = paths0.filter(x => !paths1.includes(x)).concat(paths1.filter(x => !paths0.includes(x)));
            loop = loop.concat(difference);
            cycles.push([...loop]);
        }
        return cycles;
    }

    possibleMove(p1, p2, debug = false) {
        /*TODO: Known bugs
        Sometimes the "parent edge" from DFS will be reversed and create an area outside the cycle. Check if direction is correct?
        If one large cycle is also split into 2 smaller cycles, one of them will be able to access all points on the other, but not vice versa.
         */
        let tot = new paper.Path();

        let cycles = this.getCycles();
        for (let c of cycles) {
            let total = new paper.Path();
            for (let p of c) {
                for (let s of p.segments)
                    total.add(s);
            }

            if (((total.contains(p1) && total.getLocationOf(p1) === null) && !total.contains(p2)) || ((total.contains(p2) && total.getLocationOf(p2) === null) && !total.contains(p1)))
                return false;
            //total.remove();
            tot.addSegments(total.segments);

        }
        return tot;
    }

    suggestPath(p1, p2) {
        if (this.possibleMove(p1.center, p2.center)) {
            let initCellSize = this.collisionGrid.cell_size;
            let cellSize = initCellSize;
            let suggest = this.collisionGrid.u_Astar(p1, p2);
            while (!suggest) {
                cellSize = cellSize / 2;
                this.collisionGrid = new CollisionGrid(cellSize, this, new paper.Size(750, 472));
                for (let line of this.lineGroup.children) {
                    this.collisionGrid.t_insert_line(line.curves, line);
                }
                for (let point of this.points) {
                    this.collisionGrid.t_insert_rectangle(point.bounds, point);
                }
                suggest = this.collisionGrid.u_Astar(p1, p2);
            }
            this.collisionGrid = new CollisionGrid(initCellSize, this, new paper.Size(750, 472));
            for (let line of this.lineGroup.children) {
                this.collisionGrid.t_insert_line(line.curves, line);
            }

            for (let point of this.points) {
                this.collisionGrid.t_insert_rectangle(point.bounds, point);
            }
            suggest.strokeColor = "red";
            return suggest;
        } else {
            return new paper.Path();
        }
    }

    lobbyRepresentation() {
        // Returns a representation of this gameroom for the game lobby
        return {
            capacity: `${this.playerCount}/${this.maxCapacity}`,
            id: this.id,
            name: this.name
        }
    }

    userJoin(user) {
        if (this.playerCount < 2) {
            console.log(`User ${user.username} joined game ${this.name}`);

            user.join(this.id);
            user.room = this.id;
            this.playerCount++;

            if ((!this.player1 && !this.player2) || (!this.player1)) {
                this.player1 = user;
                user.playerNum = Status.player1;
                return Status.player1;
            } else if (!this.player2) {
                this.player2 = user;
                user.playerNum = Status.player2;
                return Status.player2;
            }
        }
    }

    nextTurn() {
        this.status = this.status === Status.player1 ? Status.player2 : Status.player1;
        return this.status;
    }

    userLeave(user) {
        console.log(`User ${user.username} left game ${this.name}`);
        this.playerCount--;
        user.room = null;
        if (this.player1 === user) this.player1 = null;
        else if (this.player2 === user) this.player2 = null;

        if (this.gameStarted) {
            // End game prematurely
            let winner = user.playerNum === Status.player1 ? Status.player2 : Status.player1;

            this.gameStarted = false;
            this.gameOver(winner);
            activeRooms.delete(this.id);
        } else if (this.playerCount < 1) {
            activeRooms.delete(this.id);
        }
    }

    gameOver(winner) {
        let loser = this.player1 === winner ? Status.player2 : Status.player1;
        // TODO: add win and loss to databsae
        // createUser(winner,...)
        // createUser(loser, ...)
        // addWin(...)
        // addLoss(...)
    }
}

