#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app');
var debug = require('debug')('over-engineered-sprout:server');
var http = require('http');
var Sentencer = require('sentencer');

var paper = require('paper');
// import {CollisionGrid} from './public/scripts/modules/CollisionGrid.js';
var CollisionGrid = require('./CollisionGrid');
paper.install(this);
paper.setup([750, 472]);

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port, function () {
    console.log("listening on *:3000")
});

server.on('error', onError);
server.on('listening', onListening);


/*
* Socket IO
* */
const io = require('socket.io').listen(server);
let activeRooms = [];

io.sockets.on('connect', function (socket) {

    // Check upon connect if socket.username is in a room and if so show the game canvas for the player
    if (socket.username !== undefined) {
        activeRooms.forEach(room => {
            if (room.players.includes(socket.username)) {
                console.log("Joining ongoing game!");
                socket.emit('lobby join', 'Welcome back...', true);
            }
        });
    }


    // Client has submitted a path -> server will validate the path
    socket.on('submitPath', (pathJson, fromId, toId, fn) => {
        console.log(`${socket.username} in game ${socket.room} submits a path`);
        let game = activeRooms[socket.room];
        let from = game.points[fromId];
        let to = game.points[toId];
        let path = new paper.Path().importJSON(pathJson);
        game.collisionGrid.t_insert_line(path.curves, path);


        if (!game.isLegal(from, to, path)) {
            console.log("Illegal");
            fn(false); // Callback - path not accepted
            // path.remove();
            return false;
        } else {
            fn(true); // Callback - path accepted
            let resp = game.addPath(from, to, path);
            io.sockets.in(socket.room).emit('updateGame', from.data.id, to.data.id, resp.path, resp.pointData);
            // path.remove();
            return true;
        }


    });

    // TODO: Only emit to lobby socket
    setInterval(function () {
        let roomList = activeRooms.map(a => a.lobbyRepresentation());
        socket.emit('updateLobby', roomList);
    }, 1000);

    // when the client emits 'join', this listens and executes
    socket.on('join', (requestedUsername, fn) => {
        console.log("Client wants to join with username", requestedUsername);

        String.prototype.capitalize = function () {
            return this.charAt(0).toUpperCase() + this.slice(1);
        };

        // don't give new username unless username cookie is clean
        let username;
        if (usernameIsValid(requestedUsername)) {
            username = requestedUsername;
        } else {
            do {
                let randInt = Math.floor(Math.random() * 10);
                let adjective = Sentencer.make("{{ adjective }}").capitalize();
                username = adjective + "Guest" + randInt;
            } while (getSockets().some(e => e.username === username));
        }
        socket.username = username;
        console.log("Added user", username);
        fn(username);
    });

    socket.on('suggestPath', (from, to, fn) => {
        console.log("suggestpath")
        let game = activeRooms[socket.room];
        let suggestedPath = game.suggestPath(game.points[from], game.points[to]);
        if (suggestedPath) {
            console.log("path found")
            fn(suggestedPath.exportJSON());
        } else {
            console.log("path not found")
            fn(null);
        }
    });

    socket.on('changeUsername', (requestedUsername, fn) => {
        if (usernameIsValid(requestedUsername)) {
            console.log(`${socket.username} changed their username to ${requestedUsername}`);
            socket.username = requestedUsername;
            fn(true);
        } else fn(false)
    });

    socket.on('joinRoom', function (id, fn) {
        console.log("joinRoom", socket.username, id);
        // Helper function: emitting gameworld for sockets/players in the given room from its id
        function spawnWorldForPlayer(id) {
            let game = activeRooms[id];
            let points = [];
            for (let i = 0; i < game.points.length; i++) {
                points[i] = game.points[i].position;
            }
            io.sockets.in(id).emit('startGame', points);
        }

        // Helper function: check if player is allowed to be assigned and join a game room
        function canJoin(socket_username){
            console.log(activeRooms[id].players);
            // Only if you are one of the original players you may join the room!
            // We could submit a emit event to let socket.client know whether or not he is allowed access.
            if (activeRooms[id].players.length === 2) {
                if (activeRooms[id].players.includes(socket_username)) return true;
            }
            // First players to join are linked to game room
            else if (activeRooms[id].players.length < 2) {
                if (!activeRooms[id].players.includes(socket_username)) {
                    activeRooms[id].players.push(socket_username);
                    return true;
                }
            }
            return false;
        }


        if (activeRooms[id] === undefined) fn(false);
        else {
            io.of('/').in(id).clients((err, clients) => { // deals with callback function
                if (err) throw err;
                socket.room = id;
                if (clients.length === 0 && canJoin(socket.username)) { // Zero players in game
                    socket.join(id.toString(), () => {
                        activeRooms[id].playerCount++;
                        spawnWorldForPlayer(id);
                        // World generated but player not allowed to see it yet
                        socket.emit('lobby join', 'Please wait for the second player to join...', false);
                    }); // fixme: .room necessary?
                } else if (clients.length === 1 && canJoin(socket.username)) { // If this is the second and last player to join -> start the game!
                    socket.join(id.toString(), () => {
                        activeRooms[id].playerCount++;
                        spawnWorldForPlayer(id);
                        // Responds to clients and display lobby/world to them
                        io.in(id).emit('lobby join', 'You may now enter the game.. Enjoy!', true);
                    }); // fixme: .room necessary?
                } else {
                    io.in(id).emit('lobby join', 'Something went wrong.. Sorry', false);
                }
            });
        }
    });

    // Lets the user connect to an existing room if one exists
    // Otherwise prompts them to create their own room
    socket.on('quickplay', function (fn) {
        if (Object.keys(activeRooms).length === 0) fn(false);
        else {
            Object.keys(activeRooms).forEach((roomId) => {
                let room = activeRooms[roomId];
                if (room.playerCount < 2) {
                    fn(true, roomId);
                }
            })
        }
        fn(false);
    });

    // Client wants to create a new room => server validates room name, creates new room
    socket.on('addRoom', (roomName, map_configuration, fn) => {
        console.log("Map configuration: ");
        console.log(map_configuration);
        if (activeRooms[roomName] !== undefined) fn(false);
        else {
            console.log("Creating new room: " + roomName);
            let id = activeRooms.length;
            activeRooms[id] = new GameRoom(id, roomName);
            activeRooms[id].init(map_configuration);
            fn(true, id);
        }
    });

    socket.on('sendChatMsg', function (msg) {
        console.log("received sendChat from " + socket.username + ": " + msg);
        let timestamp = +new Date();
        io.sockets.in(socket.room).emit('updateChat', timestamp, socket.username, msg);
    });

    socket.on('disconnect', function (reason) {
        console.log(`${socket.username} disconnected`);
        console.log(socket.username + " leaving room: " + socket.room + "...");
        console.log("reason: " + reason);
        socket.leave(socket.room);
    });
});

/**
 * Normalize a port into a number, string, or false.
 */
function normalizePort(val) {
    let port = parseInt(val, 10);
    if (isNaN(port)) return val;
    if (port >= 0) return port;
    return false;
}

/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
    if (error.syscall !== 'listen') {
        throw error;
    }

    var bind = typeof port === 'string'
        ? 'Pipe ' + port
        : 'Port ' + port;

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case 'EACCES':
            console.error(bind + ' requires elevated privileges');
            process.exit(1);
            break;
        case 'EADDRINUSE':
            console.error(bind + ' is already in use');
            process.exit(1);
            break;
        default:
            throw error;
    }
}

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
    let addr = server.address();
    let bind = typeof addr === 'string'
        ? 'pipe ' + addr
        : 'port ' + addr.port;
    debug('Listening on ' + bind);
}

function getSockets() {
    return Object.keys(io.sockets.sockets);
}

function usernameIsValid(username) {
    if (!username || !(3 <= username.length <= 15) || !(/^[a-z0-9]+$/i.test(username))) return false;
    return !getSockets().some(e => io.sockets.sockets[e].username === username);
}

class GameRoom {
    constructor(id, name, players = []) {
        this.id = id;
        this.name = name;
        this.players = players;
        this.playerCount = 0;
        this.maxCapacity = 2;
        this.project = new paper.Project([750, 472]);
        this.lineGroup = new paper.Group();
        this.points = [];
        this.collisionGrid = null;
    }

    init(mapConfiguration = null, numPoints = 10) {
        this.collisionGrid = new CollisionGrid(8, this, new paper.Size(750, 472));

        let dotPoints = [];
        if (!mapConfiguration) {
            dotPoints = this.collisionGrid.g_randomPoints(numPoints, 40);
        } else {
            dotPoints = this.collisionGrid.g_randomPoints(mapConfiguration.dots, 40);
            //ToDo generate paths between points here using mapConfiguration.paths
        }

        for (let i = 0; i < dotPoints.length; i++) {
            let center = dotPoints[i];
            this.points[i] = this.createPoint(center, i, 0, []);
        }
    }

    createPoint(pos, id, connections, edges) {
        let point = new paper.Path.Circle({
            center: pos,
            radius: 10,
        });
        point.data = {
            id: id,
            edges: edges,
            connections: connections,
        };

        point.commonEdges = function (p2) {
            let inCommon = [];
            for (let edge of point.data.edges) {
                if (edge.data.vertices.includes(point) && edge.data.vertices.includes(p2))
                    inCommon.push(edge);
            }
            return inCommon;
        };

        point.dfs = function (toFind) {
            //Marker som søgende
            point.data.status = "seeking";
            //Kør dfs på alle naboer
            for (let e of point.data.edges) {
                let p = e.data.vertices.find(x => x !== point);
                if (e !== point.data.rootEdge && p !== undefined) {
                    //Er en nabo søgende eller færdig, find alle links op til nabo og tilføj liste til cycles[]
                    if (p.data.status === "") {
                        //Sæt parent til dette point
                        p.data.root = point;
                        p.data.rootEdge = e;
                        if (!(e.data.vertices[0] === p)) {
                            e.reverse();
                            e.data.vertices.reverse();
                        }
                        p.dfs(toFind);
                    } else if (p.data.status === "done") {
                        toFind.push(e);
                    }
                }
            }
            point.data.status = "done";
        };

        if (this.collisionGrid != null) {
            this.collisionGrid.t_insert_rectangle(point.bounds, point);
        }


        return point;
    }

    addPath(from, to, path) {
        let originalPath = path.clone();

        // Create new point at midpoint of path
        let pointId = this.points.length;
        let newPoint = this.createPoint(path.getPointAt(path.length / 2), pointId, 0, []);

        function save(from, to, path) {
            from.data.connections += 1;
            from.data.edges.push(path);
            to.data.connections += 1;
            to.data.edges.push(path);
            path.data.vertices = [from, to];
            path.simplify(3);
            return path;
        }

        // Separate into 2 subpaths - used for pathfinding
        let path2 = path.splitAt(path.length / 2);
        let path1 = path.clone();
        path1.insert(0, from.position);
        path2.add(to.position);

        save(from, newPoint, path1);
        save(newPoint, to, path2);

        path1.addTo(this.lineGroup);
        path2.addTo(this.lineGroup);
        path.addTo(this.lineGroup);
        this.points[pointId] = newPoint;

        // Return the unsplit path and the new poin
        let pointData = {
            // x: newPoint.
            center: newPoint.position,
            id: pointId,
            connections: 2
        };
        //todo: send newPoint.data instead

        return {path: originalPath.exportJSON(), pointData: pointData};
    }

    lobbyRepresentation() {
        // Returns a representation of this gameroom for the game lobby
        return {
            capacity: `${this.playerCount}/${this.maxCapacity}`,
            id: '' + this.id,
            name: this.name
        }
    }

    isLegal(from, to, path) {
        this.project.activate();

        if (!(from || to)) return false;
        else if (from === to && from.data.connections >= 2) return false;
        else if (from.data.connections >= 3 || to.data.connections >= 3) return false;

        // Check for intersections w. existing paths
        for (let line of this.lineGroup.getItems({type: 'path'})) {
            if (path.getIntersections(line).length > 0) return false;
        }
        return path.getIntersections(path).length <= 0;
    }

    getCycles() {
        //TODO: Sørg for at alle edges "vender" rigtigt
        //TODO: Ikke alle kanter i et loop bliver tilføjet selv om loopet er opdaget
        let toFind = [];
        for (let p of this.points) {
            p.data.root = p;
            p.data.rootEdge = null;
            p.data.status = "";
        }
        for (let p of this.points) {
            if (p.data.status !== "done") {
                p.data.root = p;
                p.dfs(toFind);
            }
        }
        let cycles = [];

        for (let t of toFind) {
            let paths0 = [];
            let paths1 = [];
            let loop = [t];
            let p0 = t.data.vertices[0];
            let p1 = t.data.vertices[1];
            while (p0.data.root !== p0) {
                paths0.push(p0.data.rootEdge);
                p0 = p0.data.root;
            }
            while (p1.data.root !== p1) {
                paths1.push(p1.data.rootEdge);
                p1 = p1.data.root;
            }
            let difference = paths0.filter(x => !paths1.includes(x)).concat(paths1.filter(x => !paths0.includes(x)));
            loop = loop.concat(difference);
            cycles.push([...loop]);
        }
        return cycles;
    }

    possibleMove(p1, p2, debug = false) {
        console.log(p1,p2);
        /*TODO: Known bugs
        Sometimes the "parent edge" from DFS will be reversed and create an area outside the cycle. Check if direction is correct?
        If one large cycle is also split into 2 smaller cycles, one of them will be able to access all points on the other, but not vice versa.
         */
        let cycles = this.getCycles();
        console.log(cycles.length);
        for (let c of cycles) {
            let total = new paper.Path();
            for (let p of c) {
                for (let s of p.segments)
                    total.add(s);
            }
            console.log("total: " + total.segments.length);
            // total.fillColor = "blue"
            // total.opacity = 0.1;
            // return total;

            if (((total.contains(p1) && total.getLocationOf(p1) === null) && !total.contains(p2)) || ((total.contains(p2) && total.getLocationOf(p2) === null) && !total.contains(p1)))
                return false;
            //total.remove();
        }
        return true;
    }

    suggestPath(p1, p2) {
        // return this.possibleMove(p1.position, p2.position);
        if (this.possibleMove(p1.position, p2.position)) {
            console.log("if possiblemove");
            let initCellSize = this.collisionGrid.cell_size;
            let cellSize = initCellSize;
            let suggest = this.collisionGrid.u_Astar(p1, p2);
            while (!suggest) {
                console.log("!suggest")
                cellSize = cellSize / 2;
                this.collisionGrid = new CollisionGrid(cellSize, this, new paper.Size(750, 472));
                for (let line of this.lineGroup.children) {
                    this.collisionGrid.t_insert_line(line.curves, line);
                }
                for (let point of this.points) {
                    this.collisionGrid.t_insert_rectangle(point.bounds, point);
                }
                suggest = this.collisionGrid.u_Astar(p1, p2);
            }
            this.collisionGrid = new CollisionGrid(initCellSize, this, new paper.Size(750, 472));
            for (let line of this.lineGroup.children) {
                this.collisionGrid.t_insert_line(line.curves, line);
            }

            for (let point of this.points) {
                this.collisionGrid.t_insert_rectangle(point.bounds, point);
            }
            suggest.strokeColor = "red";
            return suggest;
        } else {
            return new paper.Path();
        }
    }
}